cmake_minimum_required(VERSION 2.6)

project(Unpacker2 CXX)

if(NOT MSVC)
  add_definitions(-std=c++11 -Wall -Wunused-parameter)
endif()

# first try to find ROOT 6 or ROOT 5 compiled with CMake
# if present, such ROOT should be possible to find without explicit setting of any paths
find_package(ROOT 5 QUIET)

if(ROOT_FOUND)
  message(STATUS "ROOT (version ${ROOT_VERSION}) was found using ROOTConfig")
else()
  # try to locate ROOT using ROOTSYS and root-config in case ROOTSYS is not set
  set(root_prefix $ENV{ROOTSYS})
  if(root_prefix)
    list(APPEND CMAKE_MODULE_PATH ${root_prefix}/etc/cmake/)
  else()
    execute_process(COMMAND root-config --etcdir OUTPUT_VARIABLE ROOT_ETCDIR OUTPUT_STRIP_TRAILING_WHITESPACE)
    list(APPEND CMAKE_MODULE_PATH ${ROOT_ETCDIR}/cmake)
  endif()
  find_package(ROOT 5 QUIET)
  if(ROOT_FOUND)
    message(STATUS "ROOT (version ${ROOT_VERSION}) was found using FindROOT (legacy mode)")
  else()
    # as last resort, use the bundled FindROOT module
    list(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake)
    find_package(ROOT 5 REQUIRED)
    if(ROOT_FOUND)
      message(WARNING "ROOT (version ${ROOT_VERSION}) was only found using fallback mode)")
    endif()
  endif()
endif()

# add possible ROOT cmake module locations to module path
execute_process(COMMAND root-config --etcdir OUTPUT_VARIABLE ROOT_ETCDIR OUTPUT_STRIP_TRAILING_WHITESPACE)
list(APPEND CMAKE_MODULE_PATH ${ROOT_ETCDIR}/cmake)
list(APPEND CMAKE_PREFIX_PATH $ENV{ROOTSYS})
list(APPEND CMAKE_PREFIX_PATH $ENV{ROOTSYS}/etc/cmake)

# find ROOT
find_package(ROOT 5 REQUIRED)

if(ROOT_USE_FILE)
  include(${ROOT_USE_FILE})
endif()

include_directories(${ROOT_INCLUDE_DIRS})
add_definitions(${ROOT_DEFINITIONS})

find_package(Boost 1.50.0 REQUIRED
             unit_test_framework
            )
include_directories(${Boost_INCLUDE_DIRS})
add_definitions(${Boost_DEFINITIONS})

file(GLOB HEADERS *.h)
file(GLOB SOURCES *.cc)

set(DICTIONARY_REQUIRED
  EventIII.h
  TDCChannel.h
  )

set(LINKDEF_NAME Unpacker2_LinkDef.h)

file(MAKE_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/Dictionaries)
set(DICTIONARY_NAME
        ${CMAKE_CURRENT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/Dictionaries/Unpacker2_Dictionary)

include_directories(${CMAKE_CURRENT_SOURCE_DIR})
ROOT_GENERATE_DICTIONARY(${DICTIONARY_NAME} ${DICTIONARY_REQUIRED}
  LINKDEF ${LINKDEF_NAME}
  OPTIONS -p)
list(APPEND SOURCES ${DICTIONARY_NAME}.cxx)

add_library(Unpacker2 SHARED ${SOURCES} ${HEADERS})

target_link_libraries(Unpacker2
  ${Boost_LIBRARIES}
  ${ROOT_LIBRARIES}
  )

set_target_properties(Unpacker2 PROPERTIES LINKER_LANGUAGE CXX)

#unit tests
set(TESTS_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR})

foreach(dir ${TESTS_SOURCE_DIR})
  file(GLOB UNIT_TEST_SOURCES_TMP ${dir}/*Test.cpp)
  list(APPEND UNIT_TEST_SOURCES ${UNIT_TEST_SOURCES_TMP})
endforeach()

set(TESTS_DIR ${CMAKE_CURRENT_BINARY_DIR}/tests)
file(MAKE_DIRECTORY ${TESTS_DIR})
file(COPY unitTestUtils/run_tests.pl DESTINATION ${TESTS_DIR})
file(COPY unitTestUtils/parseXML.py DESTINATION ${TESTS_DIR})
foreach(test_source ${UNIT_TEST_SOURCES})
  get_filename_component(test ${test_source} NAME_WE)
  list(APPEND test_binaries ${test}.x)
  add_executable(${test}.x EXCLUDE_FROM_ALL ${test_source})
  set_target_properties(${test}.x PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${TESTS_DIR} )
  target_link_libraries(${test}.x
          Unpacker2
          ${Boost_LIBRARIES}
          )
endforeach()

add_custom_target(unpacker_tests DEPENDS ${test_binaries} Unpacker2) 
